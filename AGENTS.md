# AGENTS.md

This document is a quick-start for future AI coding agents and developers working
in this repository. It summarizes the project layout, development environment,
common workflows, and testing/documentation practices.

## Project overview
- **Purpose:** `kwdagger` defines bash-centric DAG pipelines that can be expanded
  over parameter grids, scheduled on multiple backends (serial, tmux, Slurm),
  and aggregated for reporting.
- **Primary CLIs:**
  - `python -m kwdagger.schedule` / `kwdagger schedule` – schedule a pipeline via
    `ScheduleEvaluationConfig`.
  - `python -m kwdagger.aggregate` / `kwdagger aggregate` – aggregate completed
    runs via `AggregateEvluationConfig` and generate text/plot reports.
  - `python -m kwdagger` – modal CLI defined in `kwdagger/__main__.py` that
    exposes the above commands.
- **Demo:** `kwdagger/demo/demodata.py` defines a runnable pipeline with
  per-stage CLIs and end-to-end commands used by CI and onboarding.

## Repository layout
- `kwdagger/`
  - `pipeline.py` – `Pipeline` and `ProcessNode` abstractions, networkx process
    and IO graph construction, configuration/inspection utilities, and demo
    helper `Pipeline.demo()`.
  - `schedule.py` – `ScheduleEvaluationConfig` and supporting helpers that expand
    YAML/JSON parameter matrices, prepare job directories, and dispatch to
    cmd_queue backends.
  - `aggregate.py` – `AggregateEvluationConfig` CLI that loads completed runs,
    computes parameter hash IDs, aggregates metrics, and writes reports.
  - `aggregate_loader.py` / `aggregate_plots.py` – helpers for loading pipeline
    outputs and producing tabular or plotted summaries.
  - `demo/` – demo nodes and `demodata.py` pipeline used for examples/tests.
  - `query_plan.py` – parses and applies YAML/raw query expressions to filter
    aggregated pandas DataFrames (used by the aggregation CLI for
    post-processing results).
  - `result_parser.py` – utilities for parsing node outputs.
  - `utils/` – supporting utilities (dotdicts, filesystem helpers, etc.).
- `tests/` – pytest suite covering pipeline wiring, scheduler behavior,
  aggregation, and import sanity checks.
- `docs/` – Sphinx configuration and sources; includes autogenerated API docs
  under `docs/source/auto` and a minimal external user example in
  `docs/source/manual/tutorials/twostage_pipeline`.
- Root scripts:
  - `run_tests.py` – runs pytest with coverage and xdoctest enabled.
  - `run_doctests.sh` – runs xdoctest over the package.
  - `run_linter.sh` – minimal flake8 invocation (strict error codes only).
  - `publish.sh` – legacy packaging helper; release workflows should rely on
    standard build/publish commands instead of this script.
- `requirements/` – optional requirement sets (`runtime.txt`, `tests.txt`,
  `docs.txt`, etc.) that can be composed as needed.
- `dev/` – encrypted CI key material and setup helpers (not needed for normal
  development).
- `README.rst` and `CHANGELOG.md` – high-level project description and release
  notes.

## Development environment
- **Python:** minimum version 3.10 (see `pyproject.toml`).
- **Recommended install:**
  ```bash
  python -m venv .venv
  source .venv/bin/activate
  pip install -e .
  ```
- **Optional extras:** install specific requirement sets as needed, e.g.
  `pip install -r requirements/tests.txt` for full test dependencies or
  `pip install -r requirements/docs.txt` for building docs.
- **Entrypoints:** installing the package exposes the `kwdagger` console script.

## Testing
- Primary test driver: `python run_tests.py` (runs pytest with coverage and
  xdoctest over both the `kwdagger` module and `tests/`).
- To run only the pytest suite manually: `pytest kwdagger tests` (add custom
  flags as needed; see `pyproject.toml` for default addopts and warning filters).
- Doctests: `./run_doctests.sh` executes `xdoctest kwdagger --style=google all`.
- Linting: `./run_linter.sh` runs a strict flake8 pass for fatal errors.
- Tests and doctests rely on the demo pipeline data where appropriate; keep demo
  CLI behavior stable when making changes.

## Documentation
- Sphinx sources live in `docs/` with `docs/source/index.rst` as the entry point.
- Build the HTML docs locally with `make -C docs html` (requires
  `requirements/docs.txt`). Generated output is placed under `docs/build/html`.

## Extending or refactoring
- **Pipelines:** new pipelines should compose `ProcessNode` instances with
  explicit inputs/outputs; prefer connecting specific IO nodes rather than
  relying on name-based node connections. Use `Pipeline.build_nx_graphs()` to
  verify graph integrity and `Pipeline.inspect_configurables()` to surface
  configurable parameters.
- **Scheduling:** ensure new node parameters serialize cleanly to JSON/YAML so
  they can be embedded in schedule matrices. Preserve `job_config.json` and
  `invoke.sh` generation semantics so aggregation remains compatible.
- **Aggregation:** when adding metrics or report formats, update
  `aggregate_loader.py`/`aggregate_plots.py` alongside `AggregateEvluationConfig`
  to keep CLI outputs consistent. Maintain stable parameter hash computation for
  backwards compatibility.
- **CLI updates:** adjust `kwdagger/__main__.py` if new modal commands are
  introduced. Keep demo commands in `kwdagger/demo/demodata.py` aligned with
  README examples and tests.
- **Testing guidance:** add pytest cases under `tests/` near related modules.
  Leverage xdoctest snippets within functions/classes for executable
  documentation. Favor small, isolated inputs (the demo nodes are good fixtures).

## Helpful references
- Quickstart workflow in `README.rst` shows end-to-end scheduling and
  aggregation commands using the demo pipeline.
- Coverage/pytest/xdoctest configuration lives in `pyproject.toml`.
- The `requirements/` directory documents optional dependency groups for CI,
  docs, linting, and runtime use.
